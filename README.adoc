= Experimenting with Java 8, streams and exceptions
Hugo Wood <hx4.5@free.fr>

The stream API, being FP-inspired, doesn't play with exceptions very well.

For example let's say we want to map a set of URI strings to URI objects:
[source,java]
----
uriStrings.stream().map(URI::create).collect(toList());
----

If one of the strings is not a valid URL, +map()+ still runs OK because it does nothing but register the map operation,
however, +collect()+ does call +URI::create+, which throws an +IllegalArgumentException+ and the overall operation
fails without hope of retrieving the URIs that were valid. A custom collector cannot solve this issue because
+collect()+ computes the value *before* it hands it to the collector.

The code in this repository is my attempt to solve this problem. The idea is that the collector has to be able to
control when the exception-throwing function is called in order to catch exceptions and process them, so the call has
to be delayed. To achieve this, values are mapped to supplier of values using a method I called +lazy+:
[source,java]
----
public static <T, R> Function<T, Supplier<R>> lazy(Function<T, R> f) {
    return input -> () -> f.apply(input);
}
----

Notice that +f.apply()+ is never called inside lazy, nor is it called when the returned function is called. Mapping a
+lazy()+-wrapped +A -> B+ function onto a stream of ++A++s results in a stream of suppliers of ++B++s. A downstream
collector therefore gets to work with suppliers instead of values (URIs in the example). The collector can then choose
to call (or not call) +Supplier::get+ and properly catch exceptions thrown by it.

== Examples

[source,java]
----
Collection<String> data = asList("http://elevated", "invalid\nurl", "http://abstractions");

data.stream()
    // lazy() wraps URI::create into a function that returns suppliers, in order to delay the call
    // to URI::create.
    .map(lazy(URI::create))
    // The collector can therefore catch the exceptions and swallow them, effectively collecting
    // only valid URIs. The exception to swallow has to be specified in order to correctly propagate
    // other runtime exceptions.
    .collect(discarding(IllegalArgumentException.class));
// => Stream(URI("http://elevated"), URI("http://abstractions"))

data.stream()
    .map(lazy(URI::create))
    // This collector swallows the exception too, but it does not continue to read the stream once
    // the first one is thrown.
    .collect(upto(IllegalArgumentException.class));
// => Stream(URI("http://elevated"))

try {
    data.stream()
        .map(lazy(URI::create))
        // This collector propagates the first thrown exception, but valid URIs that have already
        // been processed are accessible.
        .collect(uptoAndThrow(IllegalArgumentException.class));
catch (FailFastCollectException e) {
    // => e.getCause() returns the IllegalArgumentException
    // => e.getResults() returns Stream(URI("http://elevated"))
}

try {
    data.stream()
        .map(lazy(URI::create))
        // This collector reads the whole stream and collects all valid URIs as well as all the
        // exceptions that were thrown.
        .collect(throwingAtEnd(IllegalArgumentException.class));
catch (CollectException e) {
    // => e.getCauses() returns Collection(IllegalArgumentException)
    // => e.getResults() returns Stream(URI("http://elevated"), URI("http://abstractions"))
}
----

This method can also be used with checked exceptions, if they are first wrapped into unchecked ones.
[source,java]
----
data.stream()
    .map(lazy(sneaky(URI::new, e -> new CustomRuntimeException(e))))
    .collect(discarding(CustomRuntimeException.class));
----

The above code is simplified if the library provides a default wrapping.
[source,java]
----
data.stream()
    .map(lazy(sneaky(URI::new)))
    .collect(discardingFailures());
----

== Acknowledgement

The motivation for this experiment was triggered by the work of Yohan Legat, a co-worker at 
http://zenika.com[Zenika]. His work is also on 
https://github.com/Zenika/Blogs/tree/master/20140214-Try[GitHub] 
and he wrote a article (in French) on 
http://blog.zenika.com/index.php?post/2014/02/19/Repenser-la-propagation-des-exceptions-avec-Java-8[Zenika's technical blog].